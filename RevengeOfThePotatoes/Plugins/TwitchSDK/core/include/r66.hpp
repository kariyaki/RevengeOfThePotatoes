#pragma once
/** \file */
#include <memory>
#include <list>
#include <cstdint>
#include <vector>
#include <functional>
#include <type_traits>

/** The R66 library. */
namespace R66 {
	template<class T> class ResolveFnType { public: using Fn = std::function<void(T)>; };
	template<> class ResolveFnType<void> { public: using Fn = std::function<void()>; };
	/** A callback function which, on success, is given a result and returns void. */
	template<class T> using ResolveFn = typename ResolveFnType<T>::Fn;

	/** A callback function which, on error, is given the exception. */
	using RejectFn = std::function<void(const std::exception&)>;
}

#include "r66_strings.hpp"
#include "r66_structs_autogenerated.hpp"
#include "r66api_autogenerated.hpp"

namespace R66 {
	namespace PAL {
		class PlatformAbstractionLayer;
	}

	static void R66IgnoreError(const std::exception& i) {}

	class R66Api;
	class R66ApiImpl;
	/**
	 * @brief Represents an active EventSub subscription.
	 *
	 * Destroying this object releases the subscription.
	 *
	 * You can have multiple concurrent subscriptions to the same event type.
	 * In that case, each event will be delivered to every single subscription.
	 *
	 * Use \ref WaitForEvent to be notified immediately when the next event arrives.
	 * Whenever an event arrives even though you are not currently waiting, that event is buffered.
	 * Hence, keeping an open subscription but never receiving events from it produces a memory leak.
	 */
	template<class T>
	class TwitchEventStream {
		friend R66Api;
		friend R66ApiImpl;
		EventStreamDesc Desc;
		std::shared_ptr<IR66ApiCommon> Core;

		using WaitFn = void (IR66ApiCommon::*)(const EventStreamDesc&, ResolveFn<const T&>, RejectFn);
		EventStreamKind MyKind;
		WaitFn MyWaitFn;

		TwitchEventStream(std::shared_ptr<IR66ApiCommon> core, EventStreamKind kind, WaitFn waitFn)
			: Core(core), MyKind(kind), MyWaitFn(waitFn) {
			EventStreamRequest req;
			req.Kind = MyKind;
			Core->SubscribeToEventStream(req, [&](const EventStreamDesc& res) { this->Desc = res; }, R66IgnoreError);
		}
		TwitchEventStream(const TwitchEventStream&) = delete;
		TwitchEventStream(TwitchEventStream&& x) = default;

	public:
		~TwitchEventStream() {
			if (Core)
			{
				Core->CloseEventStream(Desc, []() {}, R66IgnoreError);
			}
			// else we have been moved from
		}

		/**
		 * @brief Wait for a new event to arrive.
		 *
		 * Invoking this function concurrently, i.e., calling it before an earlier invocation returns, is allowed.
		 * In that case, an incoming event is always delivered to the oldest currently waiting <see cref="WaitForEvent"/> call.
		 *
		 * This function waits until a matching event arrives, potentially forever.
		 * To cancel the the call, terminate your subscription by destroying the \ref TwitchEventStream object.
		 */
		void WaitForEvent(ResolveFn<const T&> resolve) {
			(Core.get()->*MyWaitFn)(Desc, resolve, R66IgnoreError);
		}
	};

	/** @brief The main R66 API class. */
	class R66Api : public IR66ApiCommon {
		virtual std::shared_ptr<IR66ApiCommon> get_shared_from_this() = 0;
	public:
		/**
		 * @brief Initialize the R66 API.
		 *
		 * This is the entry point to the library.
		 * This immediately starts several background tasks, e.g., loading credentials from disk, connecting to EventSub, etc.
		 *
		 * To stop the library, you need to drop all shared_ptr<R66Api> instances. Then, you also need to transition your
		 * platform abstraction layer implementation into a state where it rejects all incoming calls. This is necessary
		 * to ensure that all background tasks are terminted and the shared_ptr references inside these callbacks are released.
		 *
		 * @param pal The platform abstraction layer implementation to use.
		 * @param clientId OAuth Client Id
		 * @param clientSecret OAuth Secret
		 * @param useEventSubProxy Do not enable this in releases. This option instructs the plugin to connect to a local EventSubProxy instead of directly to Twitch.
		 */
		static std::shared_ptr<R66Api> Initialize(
			std::shared_ptr<PAL::PlatformAbstractionLayer> pal,
			string_view clientId,
			bool useEventSubProxy = false
		);

		/**
		 * @brief Gets information about a specific stream.
		 *
		 * @param id The channel ID to query for.
		 * @return An object describing the stream, or an empty object if the channel is offline or does not exist.
		 */
		void GetStreamInfoById(string_view id, ResolveFn<const StreamInfo&> resolve, RejectFn reject) {
			StreamQuery q;
			q.UserIds.emplace_back(id);
			QueryStreams(
				q,
				[resolve](const StreamQueryResult& r) {
					resolve((r.Streams.size() == 0) ? StreamInfo() : r.Streams[0]);
				},
				reject
			);
		}

		/**
		 * @brief Fetch a frech OAuth token that can be used for the Enhanced Experiences SDK.
		 *
		 * This call will block indefinitely if the player is not logged in.
		 */
		virtual void RefreshOAuthToken(ResolveFn<string_view> resolve) = 0;

		/**
		 * @brief Update the OAuth credentials we are currently using. Do not use in production.
		 *
		 * This function should only be used to switch to different credentials during development.
		 */
		virtual void UpdateOAuthCredentials(string_view clientId) = 0;

		/** @copydoc ChannelSubscribeEvent */
		TwitchEventStream<ChannelSubscribeEvent> SubscribeToChannelSubscribeEvents() { return { get_shared_from_this(), EventStreamKind::Subscription, &IR66ApiCommon::WaitForChannelSubscribeEvent }; }
		/** @copydoc ChannelFollowEvent */
		TwitchEventStream<ChannelFollowEvent> SubscribeToChannelFollowEvents() { return { get_shared_from_this(), EventStreamKind::Follower, &IR66ApiCommon::WaitForChannelFollowEvent }; }
		/** @copydoc ChannelCheerEvent */
		TwitchEventStream<ChannelCheerEvent> SubscribeToChannelCheerEvents() { return { get_shared_from_this(), EventStreamKind::Cheer, &IR66ApiCommon::WaitForChannelCheerEvent }; }
		/** @copydoc CustomRewardEvent */
		TwitchEventStream<CustomRewardEvent> SubscribeToCustomRewardEvents() { return { get_shared_from_this(), EventStreamKind::CustomRewardRedemption, &IR66ApiCommon::WaitForCustomRewardEvent}; }
		/** @copydoc HypeTrainEvent */
		TwitchEventStream<HypeTrainEvent> SubscribeToHypeTrainEvents() { return { get_shared_from_this(), EventStreamKind::HypeTrain, &IR66ApiCommon::WaitForHypeTrainEvent }; }
		/** @copydoc ChannelRaidEvent */
		TwitchEventStream<ChannelRaidEvent> SubscribeToChannelRaidEvents() { return { get_shared_from_this(), EventStreamKind::ChannelRaid, &IR66ApiCommon::WaitForChannelRaidEvent}; }

		// Below are some wrappers for functions that are supposed to return immediately but for simplicity everything in IR66ApiCommon is async.

		using IR66ApiCommon::GetAuthState;
		/** @copydoc IR66ApiCommon::GetAuthState */
		AuthState GetAuthState() {
			AuthState as;
			GetAuthState([&](const AuthState& res) { as = res; }, R66IgnoreError);
			return as;
		}

		using IR66ApiCommon::UnsubscribeFromPoll;
		/** @copydoc IR66ApiCommon::UnsubscribeFromPoll */
		void UnsubscribeFromPoll(string_view id) {
			UnsubscribeFromPoll(id, []() {}, R66IgnoreError);
		}

		using IR66ApiCommon::UnsubscribeFromPrediction;
		/** @copydoc IR66ApiCommon::UnsubscribeFromPrediction */
		void UnsubscribeFromPrediction(string_view id) {
			UnsubscribeFromPrediction(id, []() {}, R66IgnoreError);
		}
	};

	extern string Version;
}
